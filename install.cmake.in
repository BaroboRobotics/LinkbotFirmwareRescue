# Installation script to deploy a Qt application with all required
# dependencies. Exact behavior is operating system specific.
#   - Windows : use windeployqt and fixup_bundle to copy dlls alongside exe
#   - Mac     : TO BE WRITTEN
#   - Linux   : TO BE WRITTEN, probably nothing
#
# This file is meant to be configured with CMake's configure_file command with
# variables INSTALL_EXECUTABLES, INSTALL_LIBRARIES, and INSTALL_DIRECTORIES
# set appropriately.

##############################################################################
# Configuration

# The executable whose dependencies must be included. This MUST be a path
# relative to the install prefix. For example, if the executable is called
# 'porkypie.exe', and is installed to a directory called 'bin' with a previous
# call to CMake's install command, then INSTALL_EXECUTABLES should be
# 'bin/porkypie.exe'.
# FIXME interpret INSTALL_EXECUTABLES as a list
set(APPS ${CMAKE_INSTALL_PREFIX}/@INSTALL_EXECUTABLES@)

# A list of supplementary libraries whose dependencies must be included (i.e.,
# for a plugin opened with dlopen() which wouldn't normally appear in an ldd-
# style dependency listing).
set(LIBS @INSTALL_LIBRARIES@)

# A list of directories in which to search for dependencies, in addition to
# PATH (win32) or /usr/lib (unix), etc.
set(DIRS @INSTALL_DIRECTORIES@)

##############################################################################
# Dependency Collection and Inclusion

if(WIN32)
  # Make sure we have windeployqt.
  find_program(WINDEPLOYQT windeployqt)
  if(NOT WINDEPLOYQT)
    message(FATAL_ERROR "Oh fuck I didn't find windeployqt! Is Qt in your PATH?")
  endif()

  include(BundleUtilities)
  
  # We'll be using fixup_bundle to copy over all dynamic link dependencies to
  # the same directory as the executable(s). fixup_bundle in turns relies on
  # code in the GetPrerequisites.cmake module to enumerate those dependencies.
  # get_prerequisites does this by using dumpbin, objdump, ldd, or otool,
  # depending on what OS we're on, and the availability of those tools. ldd
  # only works on ELF (I think); objdump (from MinGW) and dumpbin (from Visual
  # C++) both work on Windows' PE binary format; otool is Mac-specific.
  # objdump under Windows is insufferably inefficient for anything but the
  # most trivial dependency graph, so we need to make sure that dumpbin is
  # available, and tell get_prerequisites to use it.

  # get_prerequisites has some Visual C++ paths hardcoded in, but the list
  # hasn't been updated since VC 9.0 (2008). get_prerequisites allows the user
  # to override its tool detection code using the the variables gp_tool and
  # gp_cmd_paths, though, so we can work around their ossified crap.

  include("${CMAKE_CURRENT_LIST_DIR}/findmsvc.cmake")
  find_path(dumpbin_dir "dumpbin.exe" PATHS "${MSVC_INSTALL_DIR}/bin")

  if(NOT dumpbin_dir)
    message(WARNING "dumpbin.exe was not found--fixup_bundle may never complete!")
  else()
    message(STATUS "Found dumpbin.exe at ${dumpbin_dir}")
    set(gp_tool dumpbin)
    set(gp_cmd_paths ${gp_cmd_paths} "${dumpbin_dir}")
  endif()

  # More hacky bullshit. We need mspdb100.dll in the path for dumpbin.exe to
  # execute (perhaps the "100" part of that dll means 10.0?). For some reason,
  # if I execute dumpbin.exe from a Qt5 MinGW command prompt, it works, but
  # the environment set up by CPack prevents the dll from being found.
  get_filename_component(mspdb_dir "${MSVC_INSTALL_DIR}/../Common7/IDE" ABSOLUTE)

  if(NOT CYGWIN AND NOT MSYS)
    # Windows cannot handle slashes in its PATH. Convert to backslashes before
    # adding it.
    # XXX There is the file(TO_NATIVE_PATH ...) command, but it didn't do what I
    # expected it to.
    string(REGEX REPLACE "/" "\\\\" mspdb_dir ${mspdb_dir})
    message(STATUS "Adding ${mspdb_dir} to PATH")
    set(ENV{PATH} "$ENV{PATH};${mspdb_dir}")
  else()
    message(WARNING "It looks like you're running MSYS or Cygwin. The deployment script does not support this environment yet, and may fail with a \"missing mspdb100.dll\" error. Try adding ${mspdb_dir} to your PATH and try again.")
  endif()

  # Now perform the actual dependency collection.
  fixup_bundle("${APPS}" "${LIBS}" "${DIRS}")
  
  message(STATUS "Now running windeployqt")

  # We could probably pass -no-libraries to windeployqt, since they would
  # already have been found by fixup_bundle, but telling windeployqt to double
  # check can't hurt.
  execute_process(COMMAND "${WINDEPLOYQT}" "${APPS}"
    RESULT_VARIABLE exit_code)

  if(${exit_code})
    message(FATAL_ERROR "windeployqt returned status ${exit_code}")
  endif()
endif()
